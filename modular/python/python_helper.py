import os
import logging
import subprocess
import venv

class PythonHelper:
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.setLevel(logging.INFO)

    def create_virtual_env(self, project_dir, env_name="venv"):
        env_path = os.path.join(project_dir, env_name)
        self.logger.info(f"Creating virtual environment in: {env_path}")
        if os.path.isdir(env_path):
            self.logger.warning(f"Virtual environment already exists at: {env_path}")
        else:
            try:
                venv.create(env_path, with_pip=True)
                self.logger.info("Virtual environment created successfully.")
            except Exception as e:
                self.logger.error(f"Error creating virtual environment: {e}")
                raise
        return env_path

    def install_requirements(self, project_dir, env_path, requirements_file="requirements.txt"):
        req_path = os.path.join(project_dir, requirements_file)
        if os.path.isfile(req_path):
            self.logger.info(f"Installing dependencies from {req_path}")
            pip_executable = os.path.join(env_path, "bin", "pip")
            command_list = [pip_executable, "install", "-r", req_path]
            self.logger.debug("Executing command: " + " ".join(command_list))
            try:
                result = subprocess.run(
                    command_list,
                    cwd=project_dir,
                    capture_output=True,
                    text=True,
                    check=True
                )
                self.logger.info("Dependencies installed successfully.")
                self.logger.debug("pip install output: " + result.stdout)
            except subprocess.CalledProcessError as e:
                self.logger.error(f"Failed to install dependencies: {e}")
                self.logger.debug(f"Stdout: {e.stdout}\nStderr: {e.stderr}")
                raise
        else:
            self.logger.warning(f"{requirements_file} does not exist in {project_dir}. Skipping installation.")

    def freeze_requirements(self, project_dir, env_path, output_file="requirements.txt"):
        self.logger.info("Freezing the environment to generate an updated requirements file.")
        pip_executable = os.path.join(env_path, "bin", "pip")
        command_list = [pip_executable, "freeze"]
        try:
            result = subprocess.run(
                command_list,
                cwd=project_dir,
                capture_output=True,
                text=True,
                check=True
            )
            output_path = os.path.join(project_dir, output_file)
            with open(output_path, "w") as f:
                f.write(result.stdout)
            self.logger.info(f"Requirements file generated at: {output_path}")
            return output_path
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to run pip freeze: {e}")
            self.logger.debug(f"Stdout: {e.stdout}\nStderr: {e.stderr}")
            raise

    def generate_requirements_with_pipreqs(self, project_dir, output_file="requirements.txt"):
        self.logger.info("Generating requirements.txt using pipreqs.")
        output_path = os.path.join(project_dir, output_file)
        command_list = ["pipreqs", project_dir, "--force", "--savepath", output_path]
        try:
            result = subprocess.run(
                command_list,
                cwd=project_dir,
                capture_output=True,
                text=True,
                check=True
            )
            self.logger.info("Requirements file generated by pipreqs.")
            self.logger.debug("pipreqs output: " + result.stdout)
            return output_path
        except subprocess.CalledProcessError as e:
            self.logger.error(f"pipreqs failed: {e}")
            self.logger.debug(f"Stdout: {e.stdout}\nStderr: {e.stderr}")
            raise

    def process_repo(self, repo_dir):
        self.logger.info(f"Processing repository at: {repo_dir}")
        env_path = self.create_virtual_env(repo_dir)
        req_file_path = os.path.join(repo_dir, "requirements.txt")
        if os.path.isfile(req_file_path) and os.path.getsize(req_file_path) > 0:
            self.logger.info("Found existing requirements.txt. Installing dependencies.")
            self.install_requirements(repo_dir, env_path)
        else:
            self.logger.info("No valid requirements.txt found. Generating one using pipreqs.")
            try:
                self.generate_requirements_with_pipreqs(repo_dir)
                if os.path.isfile(req_file_path) and os.path.getsize(req_file_path) > 0:
                    self.install_requirements(repo_dir, env_path)
                else:
                    self.logger.warning("pipreqs did not generate a valid requirements.txt file.")
            except Exception as e:
                self.logger.error(f"Failed to generate requirements.txt using pipreqs: {e}")
                with open(req_file_path, "w") as f:
                    f.write("")
                self.logger.info("Created an empty requirements.txt file.")
        final_req_file = self.freeze_requirements(repo_dir, env_path)
        self.logger.info(f"Final requirements file is at: {final_req_file}")
        return final_req_file

if __name__ == "__main__":
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )
    helper = PythonHelper()
    repo_directory = "/home/fadzi/tools/dashboard"
    try:
        helper.process_repo(repo_directory)
    except Exception as e:
        print(f"An error occurred while processing the repository: {e}")